## Big things to note about TypeScript
TypeScript provides:
- Type safety: using types to prevent programs from doing invalid things
  - a better way to understand this is that a number cannot multiply a list and calling a function with a list of strings when it actually needs a list of objects
  - Javascript tries to make the best of doing things and avoids exceptions whenever it can
  - Typescript can tell you when you made a mistake when actually run programs
- Typechecker: a special program that verifies that your code is typesafe
- Type system: a set of rules that a typechecker uses to assign types to your program
  - we can explicitly annotate types, or we can let Typescript infer most of them for us
  - Explicit way to signal the type is by `value: type`
  - In general, keep explicitly typed code to a minimum

## The Compiler
Things to start with:
- programs are files that contain a bunch of text written by programmers
- The text is parsed by a special program called a compiler, which transforms it into an abstract syntax tree (AST), a data structure that ignores things like whitespace, comments, and where you stand on the tabs versus spaces debate.
- The compiler then converts that AST to a lower-level representation called typecode.
- Then we feed that bytecode into anther program called a runtime to evaluate it and get a result
  - i.e. When you run a program, you are just telling the runtime to evaluate the bytecode generated by the compiler from the AST parsed from your source code.
- One thing special about Typescript is that typescript is first compiled to Javascript then run Javascript code

So the overall process of compiling Typescript is:
1. Typescript source code -> Typescript AST
2. AST is checked by typechecker
3. Typescript AST -> Javascript source code
4. Javascript source code -> Javascript AST
5. AST -> bytecode
6. Bytecode is evaluated by runtime

Steps 1-3 are done by TypeScript Compiler (TSC) and steps 4-6 are done by the Javascript runtime.

Typescript is a gradually typed language.
That means it works best when it knows the types of everything in your program at compile time, but it doesn't have to know every type in order to compile your program.
Typescript complains as soon as you do something invalid.
Typescript typechecks at compile time,
so you don't need to actually run your code to see the errors.
Typescript throws both syntax-related errors and type-related errors at compile time.

TSC is itself a command-line application written in Typescript, which means you need Node.js to run it.
Node.js comes with NPM, a package manager that you will use to manage your project's dependencies and orchestrate your build.

### Things to note on project
Every typescript project should include a file called tsconfig.json in its root directory.
This file is where typescript projects define things like which files should be compiled, which directory to compile them to, and which version of Javascript to emit.

Should have a tslint.json file containing our TSLint configuration, codifying whatever stylistic convensions we want for our code.

Create a src folder containing our first typescript file, let's call it index.ts.

## All About Types
Type is a set of values and the things you can do with them.

### Any
Any is a set of all values, and you can do anything with any.

Any makes our value behave like it would in regular Javascript, and totally prevents the typechecker from working its magic.

### Unknown
Like any, it represnets any value, but typescript won't let you use an unknown type until you refine it by checking what it is.

### Boolean
Represent two values: true and false.

### Number
number is the set of all numbers: integers, floats, positive, negative, infinity, NaN and so on.

### Bigint
It lets you work with large integers without running into rounding errors.

### String
string is the set of all strings and the things you can do with them like concatenate, slice and so on.

### Objects
Typescript's object types specify the shapes of objects.

Javascript is generally structually typed, so Typescript favors that style of programming over a nominally typed style.

Structural typing: a style of programming where you just care that an object has certain properties, and not what its name is.
Also called duck typing in some languages.

### Intermission: Type aliases, unions, and intersections
We can declare a type alias that points to a type.

``` typescript
type Age = number

type Person = {
  name: string
  age: Age
}

let age: Age = 55

let driver: Person = {
  name: 'Marry'
  age: age
}
```

In typescript, union is represented by |

### Arrays
Typescript arrays are special kinds of objects that support things like concatenation, pushing, searching, and slicing.

The general rule is to keep every element of the array a single type

### Tuples
Tuples are subtypes of array.
They are special way to type arrays that have fixed lengths, where the values at each index have specific, known types.

Unlike most other types, tuples have to be explicitly typed when you declare them.

### Enums
Enums are a way to enumerate the possible values for a type.
They are unordered data structures that map keys to values.

## Functions
Typescript will usually explicitly annotate function parameters - typescript will always infer types throughout the body of your function, but it won't infer types for your parameters.

``` typescript
// Named function
function greet(name: string) {
  return 'hello ' + name
}

// Function expression
let greet2 = function(name: string) {
  return 'hello ' + name
}

// Arrow function expression
let greet3 = (name: string) => {
  return 'hello ' + name
}

// Shorthand arrow function expression
let greet4 = (name: string) =>
  'hello ' + name

// Function constructor
let greet5 = new Function('name', 'return "hello " + name')
```

Additionally, we can use ? to mark parameters as optional.

``` typescript
function log(message: string, userId?: string) {
  let time = new Date().toLocaleTimeString()
  console.log(time, message, userId || 'Not signed in')
}

log('Page loaded') // Logs "12:38:31 PM Page loaded Not signed in"
log('User signed in', 'da763be') // Logs "12:38:31 PM User signed in da763be"
```

We can also rewrite the above as:

``` typescript
function log(message: string, userId = 'Not signed in') {
  let time = new Date().toISOString()
  console.log(time, message, userId)
}

log('User clicked on a button', 'da763be')
log('User signed out')
```

### Generator
Generator functions are a convenient way to, generate a bunch of values.

They give the gnerator's consumer fine control over the pace at which values are produced.
They only compute the next value when a consumer asks for it.
They can do things that can be hard to do otherwise, like generate infinite lists.
The \* before a function's name makes that function a generator.
Calling a generator returns an iterable iterator.

``` typescript
function* createFibonacciGenerator() {
  let a = 0
  let b = 1
  while (true) {
    yield a;
    [a, b] = [b, a + b]
  }
}

let fibonacciGenerator = createFibonacciGenerator() // IterableIterator<number>
fibonacciGenerator.next() // evaluates to {value: 0, done: false}
fibonacciGenerator.next() // evaluates to {value: 1, done: false}
fibonacciGenerator.next() // evaluates to {value: 1, done: false}
fibonacciGenerator.next() // evaluates to {value: 2, done: false}
fibonacciGenerator.next() // evaluates to {value: 3, done: false}
fibonacciGenerator.next() // evaluates to {value: 5, done: false}
```

### Iterators
Iterators are the flip side to generators:
while generators are a way to produce a stream of values, iterators are a way to consume those values.

Iterable: any object that contains a property called Symbol.iterator, whose value is a function that returns an iterator.

Iterator: any object that defines a method called next, which returns an object with the properties value and done.

We can manually define an iterator or an iterable by creating an object or a class that implements Symbol.iterator or next, respectively.

example:
``` typescript
let numbers = {
  *[Symbol.iterator]() {
    for (let n = 1; n <= 10; n++) {
      yield n
    }
  }
}
```

In other words, numbers is an iterable, and calling the generator function numbers\[Symbol.iterator\]() returns an iterable iterator.

### Call signatures
For a function like the following:
``` typescript
function sum(a: number, b: number): number {
  return a + b
}
```

sum is a function that takes two numbers and returns a number.
In tpyescript we can express its type as:
``` typescript
(a: number, b: number) => number
```

This is typescript's syntax for a function's type, or call signature (also called a type signature).

### Contextual Typing
``` typescript
function times(
  f: (index: number) => void,
  n: number
) {
  for (let i = 0; i < n; i++) {
    f(i)
  }
}
```

When you call times, you don't have to explicitly annotate the function you pass to times if you declare that function inline:

``` typescript
times(n => console.log(n), 4)
```

Typescript infers from context that n is a number - 
we declared that f's argument index is a number in time's signature, and Typescript is smart enough to infer that n is that argument, so it must be a number.

Note if we didn't declare f inline, Typescript wouldn't have been able to infer its type.

### Overloaded Function Types
callback is a function that you passed as an argument to another function.

The function type syntax we used in the last section - `Fn = (...) => ...` is a shorthand call signature.

``` typescript
// Shorthand call signature
type Log = (message: string, userId?: string) => void

// Full call signature
type Log = {
  (message: string, userId?: string): void
}
```

Overload function: a function with multiple call signatures

Typescript models this dynamism - overloaded function declarations, and a function's output type depending on its input type - with its static type system.

### Polymorphism
Concrete types are usful when you know precisely what type you're expecting, and want to verify that type was actually passed.
But sometimes, you don't know what type to expect beforehand, and you don't want to restrict your function's behaviour to a specific type.

Filter is meant to be a generic function - you can filter arrays of numbers, strings, objects, other arrays, anything.

Generic type parameter: a placeholder type used to enforce a type-level constraint in multiple places.
Also known as polymorphic type parameter.

A generic exmaple would be:
``` typescript
type Filter = {
  <T>(array: T[], f: (item: T) => boolean): T[]
}
```

This function filter uses a generic type parameter T;
we don't know what this type will be ahead of time, so Typescript if you can infer what it is each time we call filter that would be swell.
Typescript infers T from the type we pass in for array.
Once Typescript infers what T is for a given call to filter, it substitutes that type in for every T it sees.
T is like a placeholder type, to be filled in by the typechecker from context:
it parameterizes filter's type, which is why we call it a generic type parameter.

The funny looking angle brackets, <>, are how you declare generic type parameters;
where you place the angle brackets scopes the generics, and typescript makes sure that within their scope, all instances of the generic type parameters are eventually bound to the same concrete types.
You can declare as many comma-separated generic type parameters as you want between a pair of angle brackets.

Like a function's parameter gets rebound every time you call that function, so each call to filter gets its own binding for T:
``` typescript
type Filter = {
  <T>(array: T[], f: (item: T) => boolean): T[]
}

let filter: Filter = (array, f) => // ...

// (a) T is bound to number
filter([1, 2, 3], _ => _ > 2)

// (b) T is bound to string
filter(['a', 'b'], _ => _ !== 'b')

// (c) T is bound to {firstName: string}
let names = [
  {firstName: 'beth'},
  {firstName: 'caitlyn'},
  {firstName: 'xin'}
]
filter(names, _ => _.firstName.startsWith('b'))
```

Typescript infers these generic bindings from the types of the arguments we passed in.
Generics are a powerful way to say what your function does in a more general way than what concrete types allow.
The way to think about generics is as constraints.
Just like annotating a function parameter as n:
number constrains the value of the parameter n to the type number, so using a generic T constrains the type of whatever type you bind to T to be the same type eveywhere that T shows up.

### When are generics bound
The place where you declare a genric type doesn't just scope the type, but also dictates when typescript will bind a concrete type to your generic.

For the example of:
``` typescript
type Filter = {
  <T>(array: T[], f: (item: T) => boolean): T[]
}

let filter: Filter = (array, f) =>
  // ...
```

Because we declared <T> as part of a call signature, typescript will bind a concrete type to T when we actually call a function of type filter.
  
If we'd instead scoped T to the type alias filter, typescript would have required us to bind a type explicitly when we used filter:
``` typescript
type Filter<T> = {
  (array: T[], f: (item: T) => boolean): T[]
}
  
let filter: Filter = (array, f) => // Error TS2314: Generic type 'Filter'
                                    // ... // requires 1 type argument(s).
  
type OtherFilter = Filter // Error TS2314: Generic type 'Filter'
                          // requires 1 type argument(s).
  
let filter: Filter<number> = (array, f) =>
  // ...
  
type StringFilter = Filter<string>
let stringFilter: StringFilter = (array, f) =>
  // ...
```
Generally, typescript will bind concrete types to your generic when you use the generic:
for functions, it's when you call them;
for classes, it's when you instantiate them;
and for type alias and interfaces, it's when you use or implement them.
  
